import numpy as np
import numpy.linalg as la

import gncpy.math as gmath
from gncpy.filters.unscented_kalman_filter import UnscentedKalmanFilter


class MaxCorrEntUKF(UnscentedKalmanFilter):
    """Implements a Maximum Correntropy Unscented Kalman filter.

    Notes
    -----
    This is based on
    :cite:`Hou2018_MaximumCorrentropyUnscentedKalmanFilterforBallisticMissileNavigationSystemBasedonSINSCNSDeeplyIntegratedMode`

    Attributes
    ----------
    kernel_bandwidth : float, optional
        Bandwidth of the Gaussian Kernel. The default is 1.
    """

    def __init__(self, kernel_bandwidth=1, **kwargs):
        self.kernel_bandwidth = kernel_bandwidth

        # for correction/calc_meas_cov wrapper function
        self._past_state = np.array([[]])
        self._cur_state = np.array([[]])
        self._meas = np.array([[]])

        super().__init__(**kwargs)

    def save_filter_state(self):
        """Saves filter variables so they can be restored later."""
        filt_state = super().save_filter_state()

        filt_state["kernel_bandwidth"] = self.kernel_bandwidth
        filt_state["_past_state"] = self._past_state
        filt_state["_cur_state"] = self._cur_state
        filt_state["_meas"] = self._meas

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        super().load_filter_state(filt_state)

        self.kernel_bandwidth = filt_state["kernel_bandwidth"]
        self._past_state = filt_state["_past_state"]
        self._cur_state = filt_state["_cur_state"]
        self._meas = filt_state["_meas"]

    def _calc_meas_cov(self, timestep, n_meas, meas_fun_args):
        meas_cov, est_points, est_meas = super()._calc_meas_cov(
            timestep, n_meas, meas_fun_args
        )

        # find square root of combined covariance matrix
        n_state = self.cov.shape[0]
        n_meas = est_meas.shape[0]
        z_12 = np.zeros((n_state, n_meas))
        z_21 = np.zeros((n_meas, n_state))
        comb_cov = np.vstack(
            (np.hstack((self.cov, z_12)), np.hstack((z_21, self.meas_noise)))
        )
        comb_cov = (comb_cov + comb_cov.T) * 0.5
        sqrt_comb = la.cholesky(comb_cov)
        inv_sqrt_comb = la.inv(sqrt_comb)

        # find error vector
        pred_meas = self._est_meas(timestep, self._past_state, n_meas, meas_fun_args)[0]
        g = inv_sqrt_comb @ np.vstack((self._past_state, pred_meas))
        d = inv_sqrt_comb @ np.vstack((self._cur_state, self._meas))
        e = (d - g).ravel()

        # kernel function on error
        kern_lst = [gmath.gaussian_kernel(e_ii, self.kernel_bandwidth) for e_ii in e]
        c = np.diag(kern_lst)
        c_inv = la.inv(c)

        # calculate the measurement covariance
        scaled_mat = sqrt_comb @ c_inv @ sqrt_comb.T
        scaled_meas_noise = scaled_mat[n_state:, n_state:]
        meas_cov = meas_cov + scaled_meas_noise

        return meas_cov, est_points, est_meas

    def correct(self, timestep, meas, cur_state, past_state, **kwargs):
        """Correction function for the Max Correntropy UKF.

        This is a wrapper for the parent method to allow for additional
        parameters.

        Parameters
        ----------
        timestep : float
            Current timestep.
        meas : Nm x 1 numpy array
            Current measurement.
        cur_state : N x 1 numpy array
            Current state.
        past_state : N x 1 numpy array
            State from before the prediction step.
        **kwargs : dict, optional
            See the parent function for additional parameters.

        Returns
        -------
        tuple
            See the parent method.
        """
        self._past_state = past_state.copy()
        self._cur_state = cur_state.copy()
        self._meas = meas.copy()

        return super().correct(timestep, meas, cur_state, **kwargs)
