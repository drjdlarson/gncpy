import numpy as np
import numpy.linalg as la
from copy import deepcopy

import gncpy.dynamics.basic as gdyn
import gncpy.distributions as gdistrib
import gncpy.math as gmath
from gncpy.filters.kalman_filter import KalmanFilter
from gncpy.filters.extended_kalman_filter import ExtendedKalmanFilter


class UnscentedKalmanFilter(ExtendedKalmanFilter):
    """Implements an unscented kalman filter.

    This allows for linear or non-linear dynamics by utilizing the either the
    underlying KF or EKF functions where appropriate. It utilizes the same
    constraints on the measurement model as the EKF.

    Notes
    -----
    For details on the filter see
    :cite:`Wan2000_TheUnscentedKalmanFilterforNonlinearEstimation`. This
    implementation assumes that the noise is purely addative and as such,
    appropriate simplifications have been made. These simplifications include
    not using sigma points to track the noise, and using the fixed process and
    measurement noise covariance matrices in the filter's covariance updates.

    Attributes
    ----------
    alpha : float
        Tunig parameter for sigma points, influences the spread of sigma points about the
        mean. In range (0, 1]. If specified then a value does not need to be
        given to the :meth:`.init_sigma_points` function.
    kappa : float
        Tunig parameter for sigma points, influences the spread of sigma points about the
        mean. In range [0, inf]. If specified then a value does not need to be
        given to the :meth:`.init_sigma_points` function.
    beta : float
        Tunig parameter for sigma points. In range [0, Inf]. If specified then
        a value does not need to be given to the :meth:`.init_sigma_points` function.
        Defaults to 2 (ideal for gaussians).
    """

    def __init__(self, sigmaPoints=None, **kwargs):
        """Initialize an instance.

        Parameters
        ----------
        sigmaPoints : :class:`.distributions.SigmaPoints`, optional
            Set of initialized sigma points to use. The default is None.
        **kwargs : dict, optional
            Additional arguments for parent constructors.
        """
        self.alpha = 1
        self.kappa = 0
        self.beta = 2

        self._stateSigmaPoints = None
        if isinstance(sigmaPoints, gdistrib.SigmaPoints):
            self._stateSigmaPoints = sigmaPoints
            self.alpha = sigmaPoints.alpha
            self.beta = sigmaPoints.beta
            self.kappa = sigmaPoints.kappa
        self._use_lin_dyn = False
        self._use_non_lin_dyn = False
        self._est_meas_noise_fnc = None

        super().__init__(**kwargs)

    def save_filter_state(self):
        """Saves filter variables so they can be restored later."""
        filt_state = super().save_filter_state()

        filt_state["alpha"] = self.alpha
        filt_state["kappa"] = self.kappa
        filt_state["beta"] = self.beta

        filt_state["_stateSigmaPoints"] = deepcopy(self._stateSigmaPoints)
        filt_state["_use_lin_dyn"] = self._use_lin_dyn
        filt_state["_use_non_lin_dyn"] = self._use_non_lin_dyn
        filt_state["_est_meas_noise_fnc"] = self._est_meas_noise_fnc

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        super().load_filter_state(filt_state)

        self.alpha = filt_state["alpha"]
        self.kappa = filt_state["kappa"]
        self.beta = filt_state["beta"]

        self._stateSigmaPoints = deepcopy(filt_state["_stateSigmaPoints"])
        self._use_lin_dyn = filt_state["_use_lin_dyn"]
        self._use_non_lin_dyn = filt_state["_use_non_lin_dyn"]
        self._est_meas_noise_fnc = filt_state["_est_meas_noise_fnc"]

    def init_sigma_points(self, state0, alpha=None, kappa=None, beta=None):
        """Initializes the sigma points used by the filter.

        Parameters
        ----------
        state0 : N x 1 numpy array
            Initial state.
        alpha : float, optional
            Tunig parameter, influences the spread of sigma points about the
            mean. In range (0, 1]. If not supplied the class value will be used.
            If a value is given here then the class value will be updated.
        kappa : float, optional
            Tunig parameter, influences the spread of sigma points about the
            mean. In range [0, inf]. If not supplied the class value will be used.
            If a value is given here then the class value will be updated.
        beta : float, optional
            Tunig parameter for distribution type. In range [0, Inf]. If not
            supplied the class value will be used. If a value is given here
            then the class value will be updated.
            Defaults to 2 for gaussians.
        """
        num_axes = state0.size
        if alpha is None:
            alpha = self.alpha
        else:
            self.alpha = alpha
        if kappa is None:
            kappa = self.kappa
        else:
            self.kappa = kappa
        if beta is None:
            beta = self.beta
        else:
            self.beta = beta
        self._stateSigmaPoints = gdistrib.SigmaPoints(
            alpha=alpha, kappa=kappa, beta=beta, num_axes=num_axes
        )
        self._stateSigmaPoints.init_weights()
        self._stateSigmaPoints.update_points(state0, self.cov)

    def set_state_model(
        self,
        state_mat=None,
        input_mat=None,
        cont_time=False,
        state_mat_fun=None,
        input_mat_fun=None,
        dyn_obj=None,
        ode_lst=None,
    ):
        """Sets the state model for the filter.

        This can use either linear dynamics (by calling the kalman filters
        :meth:`gncpy.filters.KalmanFilter.set_state_model`) or non-linear dynamics
        (by calling :meth:`gncpy.filters.ExtendedKalmanFilter.set_state_model`).
        The linearness is automatically determined by the input arguments specified.

        Parameters
        ----------
        state_mat : N x N numpy array, optional
            State matrix, continuous or discrete case. The default is None.
        input_mat : N x Nu numpy array, optional
            Input matrixx, continuous or discrete case. The default is None.
        cont_time : bool, optional
            Flag inidicating if the continuous model is provided. The default
            is False.
        state_mat_fun : callable, optional
            Function that returns the `state_mat`, must take timestep and
            `*args`. The default is None.
        input_mat_fun : callable, optional
            Function that returns the `input_mat`, must take timestep, and
            `*args`. The default is None.
        dyn_obj : :class:`gncpy.dynamics.LinearDynamicsBase` or :class:`gncpy.dynamics.NonlinearDynamicsBase`, optional
            Sets the dynamics according to the class. The default is None.
        ode_lst : list, optional
            callable functions, 1 per ode/state. The callabale must have the
            signature `f(t, x, *f_args)` just like scipy.integrate's ode
            function. The default is None.

        Raises
        ------
        RuntimeError
            If an invalid state model or combination of inputs is specified.

        Returns
        -------
        None.
        """
        self._use_lin_dyn = (
            state_mat is not None
            or state_mat_fun is not None
            or isinstance(dyn_obj, gdyn.LinearDynamicsBase)
        )
        self._use_non_lin_dyn = (
            isinstance(dyn_obj, gdyn.NonlinearDynamicsBase) or ode_lst is not None
        ) and not self._use_lin_dyn

        # allow for linear or non linear dynamics by calling the appropriate parent
        if self._use_lin_dyn:
            KalmanFilter.set_state_model(
                self,
                state_mat=state_mat,
                input_mat=input_mat,
                cont_time=cont_time,
                state_mat_fun=state_mat_fun,
                input_mat_fun=input_mat_fun,
                dyn_obj=dyn_obj,
            )
        elif self._use_non_lin_dyn:
            ExtendedKalmanFilter.set_state_model(self, dyn_obj=dyn_obj, ode_lst=ode_lst)
        else:
            raise RuntimeError("Invalid state model.")

    def set_measurement_noise_estimator(self, function):
        """Sets the model used for estimating the measurement noise parameters.

        This is an optional step and the filter will work properly if this is
        not called. If it is called, the measurement noise will be estimated
        during the filter's correction step and the measurement noise attribute
        will not be used.

        Parameters
        ----------
        function : callable
            A function that implements the prediction and correction steps for
            an appropriate filter to estimate the measurement noise covariance
            matrix. It must have the signature `f(est_meas)` where `est_meas`
            is an Nm x 1 numpy array and it must return an Nm x Nm numpy array
            representing the measurement noise covariance matrix.

        Returns
        -------
        None.
        """
        self._est_meas_noise_fnc = function

    def predict(
        self,
        timestep,
        cur_state,
        cur_input=None,
        state_mat_args=(),
        input_mat_args=(),
        dyn_fun_params=(),
    ):
        """Prediction step of the UKF.

        Automatically calls the state propagation method from either
        :meth:`gncpy.KalmanFilter.predict` or :meth:`gncpy.ExtendedKalmanFilter.predict`
        depending on if a linear or non-linear state model was specified.
        If a linear model is used only the parameters that can be passed to
        :meth:`gncpy.KalmanFilter.predict` will be used by this function.
        Otherwise the parameters for :meth:`gncpy.ExtendedKalmanFilter.predict`
        will be used.

        Parameters
        ----------
        timestep : float
            Current timestep.
        cur_state : N x 1 numpy array
            Current state.
        cur_input : N x Nu numpy array, optional
            Current input for linear models. The default is None.
        state_mat_args : tuple, optional
            keyword arguments for the get state matrix function if one has
            been specified or the propagate state function if using a linear
            dynamic object. The default is ().
        input_mat_args : tuple, optional
            keyword arguments for the get input matrix function if one has
            been specified or the propagate state function if using a linear
            dynamic object. The default is ().
        dyn_fun_params : tuple, optional
            Extra arguments to be passed to the dynamics function for non-linear
            models. The default is ().

        Raises
        ------
        RuntimeError
            If a state model has not been set.

        Returns
        -------
        next_state : N x 1 numpy array
            The next state.

        """
        self._stateSigmaPoints.update_points(cur_state, self.cov)

        # propagate points
        if self._use_lin_dyn:
            new_points = np.array(
                [
                    KalmanFilter._predict_next_state(
                        self,
                        timestep,
                        x.reshape((x.size, 1)),
                        cur_input,
                        state_mat_args,
                        input_mat_args,
                    )[0].ravel()
                    for x in self._stateSigmaPoints.points
                ]
            )
        elif self._use_non_lin_dyn:
            new_points = np.array(
                [
                    ExtendedKalmanFilter._predict_next_state(
                        self, timestep, x.reshape((x.size, 1)), dyn_fun_params
                    )[0].ravel()
                    for x in self._stateSigmaPoints.points
                ]
            )
        else:
            raise RuntimeError("State model not specified")
        self._stateSigmaPoints.points = new_points

        # update covariance
        self.cov = self._stateSigmaPoints.cov + self.proc_noise
        self.cov = (self.cov + self.cov.T) * 0.5

        # estimate weighted state output
        next_state = self._stateSigmaPoints.mean

        return next_state

    def _calc_meas_cov(self, timestep, n_meas, meas_fun_args):
        est_points = np.array(
            [
                self._est_meas(timestep, x.reshape((x.size, 1)), n_meas, meas_fun_args)[
                    0
                ]
                for x in self._stateSigmaPoints.points
            ]
        )
        est_meas = gmath.weighted_sum_vec(
            self._stateSigmaPoints.weights_mean, est_points
        )
        diff = est_points - est_meas
        meas_cov_lst = diff @ diff.reshape((est_points.shape[0], 1, est_meas.size))

        partial_cov = gmath.weighted_sum_mat(
            self._stateSigmaPoints.weights_cov, meas_cov_lst
        )
        # estimate the measurement noise if applicable
        if self._est_meas_noise_fnc is not None:
            self.meas_noise = self._est_meas_noise_fnc(est_meas, partial_cov)
        meas_cov = self.meas_noise + partial_cov

        return meas_cov, est_points, est_meas

    def correct(self, timestep, meas, cur_state, meas_fun_args=()):
        """Correction step of the UKF.

        Parameters
        ----------
        timestep : float
            Current timestep.
        meas : Nm x 1 numpy array
            Current measurement.
        cur_state : N x 1 numpy array
            Current state.
        meas_fun_args : tuple, optional
            Arguments for the measurement matrix function if one has
            been specified. The default is ().

        Raises
        ------
        :class:`.errors.ExtremeMeasurementNoiseError`
            If estimating the measurement noise and the measurement fit calculation fails.
        LinAlgError
            Numpy exception raised if not estimating noise and measurement fit fails.

        Returns
        -------
        next_state : N x 1 numpy array
            corrected state.
        meas_fit_prob : float
            measurement fit probability assuming a Gaussian distribution.

        """
        meas_cov, est_points, est_meas = self._calc_meas_cov(
            timestep, meas.size, meas_fun_args
        )

        state_diff = self._stateSigmaPoints.points - cur_state.ravel()
        meas_diff = (est_points - est_meas).reshape(
            (est_points.shape[0], 1, est_meas.size)
        )
        cross_cov_lst = state_diff.reshape((*state_diff.shape, 1)) @ meas_diff
        cross_cov = gmath.weighted_sum_mat(
            self._stateSigmaPoints.weights_cov, cross_cov_lst
        )

        if self.use_cholesky_inverse:
            sqrt_inv_meas_cov = la.inv(la.cholesky(meas_cov))
            inv_meas_cov = sqrt_inv_meas_cov.T @ sqrt_inv_meas_cov
        else:
            inv_meas_cov = la.inv(meas_cov)
        gain = cross_cov @ inv_meas_cov
        inov = meas - est_meas

        self.cov = self.cov - gain @ meas_cov @ gain.T
        self.cov = (self.cov + self.cov.T) * 0.5
        next_state = cur_state + gain @ inov

        meas_fit_prob = self._calc_meas_fit(meas, est_meas, meas_cov)

        return next_state, meas_fit_prob
