import numpy as np
import numpy.random as rnd
from copy import deepcopy
from warnings import warn

import gncpy.distributions as gdistrib
import gncpy.errors as gerr
from gncpy.filters.bayes_filter import BayesFilter


class BootstrapFilter(BayesFilter):
    """Stripped down version of the :class:`.ParticleFilter`.

    This is an alternative implementation of a basic Particle filter. This
    removes some of the quality of life features of the :class:`.ParticleFilter`
    class and can be more complicated to setup. But it may provide runtime improvements
    for simple cases. Most times it is advised to use the :class:`.ParticleFilter`
    instead of this class. Most other derived classes use the :class:`.ParticleFilter`
    class as a base.
    """

    def __init__(
        self,
        importance_dist_fnc=None,
        importance_weight_fnc=None,
        particleDistribution=None,
        rng=None,
        **kwargs
    ):
        """Initializes the object.

        Parameters
        ----------
        importance_dist_fnc : callable, optional
            Must have the signature `f(parts, rng)` where `parts` is an
            instance of :class:`.distributions.SimpleParticleDistribution`
            and `rng` is a numpy random generator. It must return a numpy array
            of new particles for a :class:`.distributions.SimpleParticleDistribution`.
            Any state transitions to a new timestep must happen within this
            function. The default is None.
        importance_weight_fnc : callable, optional
            Must have the signature `f(meas, parts)` where `meas` is an Nm x 1
            numpy array representing the measurement and `parts` is the
            numpy array of particles from a :class:`.distributions.SimpleParticleDistribution`
            object. It must return a numpy array of weights, one for each
            particle. The default is None.
        particleDistribution : :class:`.distributions.SimpleParticleDistribution`, optional
            Initial particle distribution to use. The default is None.
        rng : numpy random generator, optional
            Random number generator to use. If none supplied then the numpy default
            is used. The default is None.
        **kwargs : dict
            Additional arguments for the parent constructor.
        """
        super().__init__(**kwargs)
        self.importance_dist_fnc = importance_dist_fnc
        self.importance_weight_fnc = importance_weight_fnc
        if particleDistribution is None:
            self.particleDistribution = gdistrib.SimpleParticleDistribution()
        else:
            self.particleDistribution = particleDistribution
        if rng is None:
            self.rng = rnd.default_rng()
        else:
            self.rng = rng

    def save_filter_state(self):
        """Saves filter variables so they can be restored later."""
        filt_state = super().save_filter_state()
        filt_state["importance_dist_fnc"] = self.importance_dist_fnc
        filt_state["importance_weight_fnc"] = self.importance_weight_fnc
        filt_state["particleDistribution"] = deepcopy(self.particleDistribution)
        filt_state["rng"] = self.rng

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        super().load_filter_state(filt_state)

        self.importance_dist_fnc = filt_state["importance_dist_fnc"]
        self.importance_weight_fnc = filt_state["importance_weight_fnc"]
        self.particleDistribution = filt_state["particleDistribution"]
        self.rng = filt_state["rng"]

    def predict(self, timestep):
        """Prediction step of the filter.

        Calls the importance distribution function to generate new samples of
        particles.

        Parameters
        ----------
        timestep : float
            Current timestep.

        Returns
        -------
        N x 1
            mean estimate of the particles.
        """
        self.particleDistribution.particles = self.importance_dist_fnc(
            self.particleDistribution, self.rng
        )

        shape = (self.particleDistribution.particles.shape[1], 1)
        return np.mean(self.particleDistribution.particles, axis=0).reshape(shape)

    def correct(self, timestep, meas):
        """Correction step of the filter.

        Parameters
        ----------
        timestep : float
            Current timestep.
        meas : Nm x 1 numpy array
            Current measurement.

        Raises
        ------
        :class:`gerr.ParticleDepletionError`
            If all particles weights sum to zero (all particles will be removed).

        Returns
        -------
        N x 1 numpy array
            mean estimate of the particles.
        """
        self.particleDistribution.weights *= self.importance_weight_fnc(
            meas, self.particleDistribution.particles
        )
        tot = np.sum(self.particleDistribution.weights)
        if tot <= 0:
            raise gerr.ParticleDepletionError("Importance weights sum to 0.")
        self.particleDistribution.weights /= tot

        # selection
        num_parts = self.particleDistribution.num_particles
        keep_inds = self.rng.choice(
            np.array(range(self.particleDistribution.weights.size)),
            p=self.particleDistribution.weights,
            size=num_parts,
        )
        unique_inds, counts = np.unique(keep_inds, return_counts=True)
        self.particleDistribution.num_parts_per_ind = counts
        self.particleDistribution.particles = self.particleDistribution.particles[
            unique_inds, :
        ]
        self.particleDistribution.weights = (
            1 / num_parts * np.ones(self.particleDistribution.particles.shape[0])
        )

        if unique_inds.size <= 1:
            msg = "Only {:d} particles selected".format(unique_inds.size)
            raise gerr.ParticleDepletionError(msg)
        # weights are all equal here so don't need weighted sum
        shape = (self.particleDistribution.particles.shape[1], 1)
        return np.mean(self.particleDistribution.particles, axis=0).reshape(shape)

    def set_state_model(self, **kwargs):
        """Not used by the Bootstrap filter."""
        warn(
            "Not used by BootstrapFilter, directly handled by importance_dist_fnc.",
            RuntimeWarning,
        )

    def set_measurement_model(self, **kwargs):
        """Not used by the Bootstrap filter."""
        warn(
            "Not used by BootstrapFilter, directly handled by importance_weight_fnc.",
            RuntimeWarning,
        )

    def plot_particles(self, inds, **kwargs):
        """Wrapper for :class:`.distributions.SimpleParticleDistribution.plot_particles`."""
        return self.particleDistribution.plot_particles(inds, **kwargs)
