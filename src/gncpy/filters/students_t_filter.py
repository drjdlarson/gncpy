import numpy as np
import numpy.linalg as la
import scipy.stats as stats

from gncpy.filters.kalman_filter import KalmanFilter


class StudentsTFilter(KalmanFilter):
    r"""Implementation of a Students T filter.

    This is based on :cite:`Liu2018_AStudentsTMixtureProbabilityHypothesisDensityFilterforMultiTargetTrackingwithOutliers`
    and :cite:`Roth2013_AStudentsTFilterforHeavyTailedProcessandMeasurementNoise`
    and uses moment matching to limit the degree of freedom growth.

    Notes
    -----
    This models the multi-variate Student's t-distribution as

    .. math::
        \begin{align}
            p(x) &= \frac{\Gamma(\frac{\nu + 2}{2})}{\Gamma(\frac{\nu}{2})}
                \frac{1}{(\nu \pi)^{d/2}}
                \frac{1}{\sqrt{\vert \Sigma \vert}}\left( 1 +
                \frac{\Delta^2}{\nu}\right)^{-\frac{\nu + 2}{\nu}} \\
            \Delta^2 &= (x - m)^T \Sigma^{-1} (x - m)
        \end{align}

    or compactly as :math:`St(x; m,\Sigma, \nu) = p(x)` for scale matrix
    :math:`\Sigma` and degree of freedom :math:`\nu`

    Attributes
    ----------
    scale : N x N numpy array, optional
        Scaling matrix of the Students T distribution.  The default is np.array([[]]).
    dof : int , optional
        Degree of freedom for the state distribution. The default is 3.
    proc_noise_dof : int, optional
        Degree of freedom for the process noise model. The default is 3.
    meas_noise_dof : int, optional
        Degree of freedom for the measurement noise model. The default is 3.
    use_moment_matching : bool, optional
        Flag indicating if moment matching is used to maintain the heavy tail
        property as the filter propagates over time. The default is True.
    """

    def __init__(
        self,
        scale=np.array([[]]),
        dof=3,
        proc_noise_dof=3,
        meas_noise_dof=3,
        use_moment_matching=True,
        **kwargs
    ):
        self.scale = scale
        self.dof = dof
        self.proc_noise_dof = proc_noise_dof
        self.meas_noise_dof = meas_noise_dof
        self.use_moment_matching = use_moment_matching

        super().__init__(**kwargs)

    def save_filter_state(self):
        """Saves filter variables so they can be restored later."""
        filt_state = super().save_filter_state()

        filt_state["scale"] = self.scale
        filt_state["dof"] = self.dof
        filt_state["proc_noise_dof"] = self.proc_noise_dof
        filt_state["meas_noise_dof"] = self.meas_noise_dof
        filt_state["use_moment_matching"] = self.use_moment_matching

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        super().load_filter_state(filt_state)

        self.scale = filt_state["scale"]
        self.dof = filt_state["dof"]
        self.proc_noise_dof = filt_state["proc_noise_dof"]
        self.meas_noise_dof = filt_state["meas_noise_dof"]
        self.use_moment_matching = filt_state["use_moment_matching"]

    @property
    def cov(self):
        """Read only covariance matrix.

        This is calculated from the scale matrix and degree of freedom.

        Raises
        ------
        RuntimeError
            If the degree of freedom is less than or equal to 2

        Returns
        -------
        N x 1 numpy array
            Calcualted covariance matrix
        """
        if self.dof <= 2:
            msg = "Degrees of freedom ({}) must be > 2"
            raise RuntimeError(msg.format(self.dof))
        return self.dof / (self.dof - 2) * self.scale

    @cov.setter
    def cov(self, cov):
        pass

    def predict(
        self, timestep, cur_state, cur_input=None, state_mat_args=(), input_mat_args=()
    ):
        """Implements the prediction step of the Students T filter.

        Parameters
        ----------
        timestep : float
            Current timestep.
        cur_state : N x 1 numpy array
            Current state.
        cur_input : N x Nu numpy array, optional
            Current input. The default is None.
        state_mat_args : tuple, optional
            keyword arguments for the get state matrix function if one has
            been specified or the propagate state function if using a dynamic
            object. The default is ().
        input_mat_args : tuple, optional
            keyword arguments for the get input matrix function if one has
            been specified or the propagate state function if using a dynamic
            object. The default is ().

        Returns
        -------
        next_state : N x 1 numpy array
            Next state.
        """
        next_state, state_mat = self._predict_next_state(
            timestep, cur_state, cur_input, state_mat_args, input_mat_args
        )

        factor = (
            self.proc_noise_dof
            * (self.dof - 2)
            / (self.dof * (self.proc_noise_dof - 2))
        )
        self.scale = state_mat @ self.scale @ state_mat.T + factor * self.proc_noise
        self.scale = (self.scale + self.scale.T) * 0.5

        return next_state

    def _meas_fit_pdf(self, meas, est_meas, meas_cov):
        return stats.multivariate_t.pdf(
            meas.ravel(), loc=est_meas.ravel(), shape=meas_cov, df=self.meas_noise_dof
        )

    def correct(self, timestep, meas, cur_state, meas_fun_args=()):
        """Implements the correction step of the students T filter.

        This also performs the moment matching.

        Parameters
        ----------
        timestep : float
            Current timestep.
        meas : Nm x 1 numpy array
            Current measurement.
        cur_state : N x 1 numpy array
            Current state.
        meas_fun_args : tuple, optional
            Arguments for the measurement matrix function if one has
            been specified. The default is ().

        Returns
        -------
        next_state : N x 1 numpy array
            The corrected state.
        meas_fit_prob : float
            Goodness of fit of the measurement based on the state and
            scale assuming Student's t noise.
        """
        est_meas, meas_mat = self._est_meas(
            timestep, cur_state, meas.size, meas_fun_args
        )

        # get gain
        scale_meas_T = self.scale @ meas_mat.T
        factor = (
            self.meas_noise_dof
            * (self.dof - 2)
            / (self.dof * (self.meas_noise_dof - 2))
        )
        inov_cov = meas_mat @ scale_meas_T + factor * self.meas_noise
        inov_cov = (inov_cov + inov_cov.T) * 0.5
        if self.use_cholesky_inverse:
            sqrt_inv_inov_cov = la.inv(la.cholesky(inov_cov))
            inv_inov_cov = sqrt_inv_inov_cov.T @ sqrt_inv_inov_cov
        else:
            inv_inov_cov = la.inv(inov_cov)
        gain = scale_meas_T @ inv_inov_cov
        P_kk = (np.eye(cur_state.shape[0]) - gain @ meas_mat) @ self.scale

        # update state
        innov = meas - est_meas
        delta_2 = innov.T @ inv_inov_cov @ innov
        next_state = cur_state + gain @ innov

        # moment matching
        if self.use_moment_matching:
            dof_p = self.dof + meas.size
            factor = (self.dof + delta_2) / dof_p
            P_k = factor * P_kk

            factor = dof_p * (self.dof - 2) / (self.dof * (dof_p - 2))
            self.scale = factor * P_k
        else:
            self.scale = P_kk
        # get measurement fit
        meas_fit_prob = self._calc_meas_fit(meas, est_meas, inov_cov)

        return next_state, meas_fit_prob
