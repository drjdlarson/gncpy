import numpy as np
from warnings import warn
from copy import deepcopy
from gncpy.filters.particle_filter import ParticleFilter


class InteractingMultipleModel:
    """Implementation of an InteractingMultipleModel (IMM) filter.

    This filter combines several inner filters with different dynamic models
    and selects the best estimate based on prior predictions and measurement
    updates.
    """

    def __init__(self):
        self.in_filt_list = []
        self.cur_filt_ind = 0
        self.model_trans_mat = np.array([[]])
        self.filt_weights = np.array([])
        self.cur_out_state = np.array([])
        self.filt_weight_history = np.array([[]])
        self.mean_list = []
        self.cov_list = []

    @property
    def cov(self):
        """Covariance for the IMM Filter."""
        cur_cov = np.zeros((np.shape(self.cov_list[0])))
        for ii in range(0, np.shape(self.cov_list)[0]):
            cur_cov = cur_cov + self.filt_weights[ii] * (
                self.cov_list[ii]
                + (
                    self.mean_list[ii].reshape(np.shape(self.mean_list[0]))
                    - self.cur_out_state.reshape(np.shape(self.mean_list[0]))
                )
                @ (
                    self.mean_list[ii].reshape(np.shape(self.mean_list[0]))
                    - self.cur_out_state.reshape(np.shape(self.mean_list[0]))
                ).T
            )
        return cur_cov

    @cov.setter
    def cov(self, val):
        warn("Covariance is read only. SKIPPING")

    def save_filter_state(self):
        """Saves filter variables so they can be restored later.

        Note that to pickle the resulting dictionary the :code:`dill` package
        may need to be used due to potential pickling of functions.
        """
        filt_state = {}
        filt_tup_list = []
        for filt in self.in_filt_list:
            filt_dict = filt.save_filter_state()
            filt_tup_list.append((type(filt), filt_dict))

        filt_state["in_filt_list"] = filt_tup_list.copy()
        filt_state["model_trans_mat"] = self.model_trans_mat.copy()
        filt_state["filt_weights"] = self.filt_weights.copy()
        filt_state["cur_out_state"] = self.cur_out_state.copy()
        filt_state["filt_weight_history"] = self.filt_weight_history.copy()
        filt_state["mean_list"] = deepcopy(self.mean_list)
        filt_state["cov_list"] = deepcopy(self.cov_list)

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        self.in_filt_list = []
        filt_tup_list = filt_state["in_filt_list"]
        for tup in filt_tup_list:
            cls_type = tup[0]
            if cls_type is not None:
                filt = cls_type()
                filt.load_filter_state(tup[1])
            else:
                filt = None
            self.in_filt_list.append(filt)
        self.model_trans_mat = filt_state["model_trans_mat"]
        self.filt_weights = filt_state["filt_weights"]
        self.cur_out_state = filt_state["cur_out_state"]
        self.filt_weight_history = filt_state["filt_weight_history"]
        self.mean_list = filt_state["mean_list"]
        self.cov_list = filt_state["cov_list"]

    def initialize_states(self, init_means, init_covs, init_weights=None):
        self.mean_list = init_means
        self.cov_list = init_covs
        if len(init_means) != len(self.in_filt_list) or len(init_covs) != len(
            self.in_filt_list
        ):
            raise ValueError(
                "Number of means or covariances does not match number of inner filters"
            )
        for ii in range(0, len(self.in_filt_list)):
            self.in_filt_list[ii].mean = self.mean_list[ii].reshape((-1, 1))
            self.in_filt_list[ii].cov = self.cov_list[ii]

        if init_weights is not None:
            self.filt_weights = init_weights
        else:
            self.filt_weights = np.ones(len(self.in_filt_list)) / len(self.in_filt_list)
        self.filt_weight_history = np.array(self.filt_weights)
        out_state = np.zeros((self.mean_list[0].size, 1))
        for ii in range(len(self.in_filt_list)):
            out_state += self.filt_weights[ii] * self.mean_list[ii]
        self.cur_out_state = out_state

    def initialize_filters(self, filter_lst, model_trans):
        if (
            len(filter_lst) != np.shape(model_trans)[0]
            or len(filter_lst) != np.shape(model_trans)[1]
            or np.shape(model_trans)[0] != np.shape(model_trans)[1]
        ):
            raise ValueError(
                "filter list must be same size as square matrix model_trans"
            )
        self.model_trans_mat = model_trans
        self.in_filt_list = filter_lst

    def set_models(
        self, filter_lst, model_trans, init_means, init_covs, init_weights=None
    ):
        """Set different filters and dynamics models for an IMM filter."""

        self.initialize_filters(filter_lst, model_trans)
        self.initialize_states(init_means, init_covs, init_weights=init_weights)

    def set_measurement_model(self, **kwargs):
        for filt in self.in_filt_list:
            filt.set_measurement_model(**kwargs)

    def predict(self, timestep, *args, **kwargs):
        """Prediction step for the IMM filter."""
        new_weight_list = []
        new_mean_list = []
        new_cov_list = []

        # Perform inner filter predictions
        for ii, filt in enumerate(self.in_filt_list):
            new_weight = 0
            weighted_state = np.zeros(self.mean_list[0].shape)
            weighted_cov = np.zeros(np.shape(self.cov_list[0]))
            # Calculate weighted input states and new weights
            for jj in range(0, len(self.in_filt_list)):
                new_weight += self.model_trans_mat[ii][jj] * self.filt_weights[jj]
                weighted_state += (
                    self.model_trans_mat[ii][jj]
                    * self.filt_weights[jj]
                    * self.mean_list[jj]
                )
            # Normalize weighted state
            weighted_state = weighted_state / new_weight

            # Iterate through all means/weights to compile weighted covariance
            for jj in range(0, len(self.in_filt_list)):
                weighted_cov += (
                    self.model_trans_mat[ii][jj]
                    * self.filt_weights[jj]
                    * (
                        self.cov_list[jj]
                        + (self.mean_list[jj] - weighted_state)
                        @ (self.mean_list[jj] - weighted_state).T
                    )
                )
            weighted_cov = weighted_cov / new_weight

            # Perform inner filter prediction
            if not isinstance(filt, ParticleFilter):
                filt.cov = weighted_cov.copy()
                new_mean_list.append(
                    filt.predict(timestep, weighted_state, *args, **kwargs)
                )
                new_cov_list.append(filt.cov.copy())
            else:
                raise ValueError("Particle Filters not enabled with IMM")
            new_weight_list.append(new_weight)
        self.mean_list = new_mean_list
        self.cov_list = new_cov_list
        self.filt_weights = np.array(new_weight_list)
        self.filt_weight_history = np.vstack(
            (self.filt_weight_history, new_weight_list)
        )
        # Normalize weights
        if np.sum(new_weight_list) != 1:
            new_weight_list = new_weight_list / np.sum(new_weight_list)
        # Output predicted state
        out_state = np.zeros(self.mean_list[0].shape)
        for ii in range(0, len(self.in_filt_list)):
            out_state += new_weight_list[ii] * self.mean_list[ii]
        self.cur_out_state = out_state
        return out_state

    def correct(self, timestep, meas, *args, **kwargs):
        """Measurement correction step for the IMM filter."""
        new_weight_list = np.zeros(np.shape(self.filt_weights))
        meas_fit_prob_list = np.zeros(len(self.in_filt_list))
        for ii, filt in enumerate(self.in_filt_list):
            if not isinstance(filt, ParticleFilter):
                (self.mean_list[ii], meas_fit_prob_list[ii]) = filt.correct(
                    timestep, meas, self.mean_list[ii].reshape((-1, 1))
                )
                self.cov_list[ii] = filt.cov.copy()
            new_weight_list[ii] = meas_fit_prob_list[ii] * self.filt_weights[ii]
        out_meas_fit_prob = np.sum(new_weight_list)
        if np.sum(new_weight_list) == 0:
            new_weight_list = new_weight_list * 0
        else:
            new_weight_list = new_weight_list / np.sum(new_weight_list)
        self.filt_weights = new_weight_list

        out_state = np.zeros(self.mean_list[0].shape)
        for ii in range(len(self.in_filt_list)):
            out_state += new_weight_list[ii] * self.mean_list[ii]

        self.cur_out_state = out_state
        return (out_state, out_meas_fit_prob)
