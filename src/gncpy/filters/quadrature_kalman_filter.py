import numpy as np
import numpy.linalg as la

import gncpy.distributions as gdistrib
import gncpy.dynamics.basic as gdyn
import gncpy.math as gmath
from gncpy.filters.kalman_filter import KalmanFilter
from gncpy.filters.extended_kalman_filter import ExtendedKalmanFilter


class QuadratureKalmanFilter(ExtendedKalmanFilter):
    """Implementation of a Quadrature Kalman Filter.

    Notes
    -----
    This implementation is based on
    :cite:`Arasaratnam2007_DiscreteTimeNonlinearFilteringAlgorithmsUsingGaussHermiteQuadrature`
    and uses Gauss-Hermite quadrature points. It inherits from EKF to allow
    for easier implementation of non-linear dynamics.

    Attributes
    ----------
    quadPoints : :class:`gncpy.distributions.QuadraturePoints`
        Quadrature points used by the filter.
    """

    def __init__(self, points_per_axis=None, **kwargs):
        super().__init__(**kwargs)

        self.quadPoints = gdistrib.QuadraturePoints(points_per_axis=points_per_axis)
        self._sqrt_cov = np.array([[]])
        self._use_lin_dyn = False
        self._use_non_lin_dyn = False

    def save_filter_state(self):
        """Saves filter variables so they can be restored later."""
        filt_state = super().save_filter_state()

        filt_state["quadPoints"] = self.quadPoints

        filt_state["_sqrt_cov"] = self._sqrt_cov
        filt_state["_use_lin_dyn"] = self._use_lin_dyn
        filt_state["_use_non_lin_dyn"] = self._use_non_lin_dyn

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        super().load_filter_state(filt_state)

        self.quadPoints = filt_state["quadPoints"]
        self._sqrt_cov = filt_state["_sqrt_cov"]
        self._use_lin_dyn = filt_state["_use_lin_dyn"]
        self._use_non_lin_dyn = filt_state["_use_non_lin_dyn"]

    @property
    def points_per_axis(self):
        """Wrapper for the  number of quadrature points per axis."""
        return self.quadPoints.points_per_axis

    @points_per_axis.setter
    def points_per_axis(self, val):
        self.quadPoints.points_per_axis = val

    def set_state_model(
        self,
        state_mat=None,
        input_mat=None,
        cont_time=False,
        state_mat_fun=None,
        input_mat_fun=None,
        dyn_obj=None,
        ode_lst=None,
    ):
        """Sets the state model for the filter.

        This can use either linear dynamics (by calling the kalman filters
        :meth:`gncpy.filters.KalmanFilter.set_state_model`) or non-linear dynamics
        (by calling :meth:`gncpy.filters.ExtendedKalmanFilter.set_state_model`).
        The linearness is automatically determined by the input arguments specified.

        Parameters
        ----------
        state_mat : N x N numpy array, optional
            State matrix, continuous or discrete case. The default is None.
        input_mat : N x Nu numpy array, optional
            Input matrixx, continuous or discrete case. The default is None.
        cont_time : bool, optional
            Flag inidicating if the continuous model is provided. The default
            is False.
        state_mat_fun : callable, optional
            Function that returns the `state_mat`, must take timestep and
            `*args`. The default is None.
        input_mat_fun : callable, optional
            Function that returns the `input_mat`, must take timestep, and
            `*args`. The default is None.
        dyn_obj : :class:`gncpy.dynamics.LinearDynamicsBase` or :class:`gncpy.dynamics.NonlinearDynamicsBase`, optional
            Sets the dynamics according to the class. The default is None.
        ode_lst : list, optional
            callable functions, 1 per ode/state. The callabale must have the
            signature `f(t, x, *f_args)` just like scipy.integrate's ode
            function. The default is None.

        Raises
        ------
        RuntimeError
            If an invalid state model or combination of inputs is specified.

        Returns
        -------
        None.
        """
        self._use_lin_dyn = (
            state_mat is not None
            or state_mat_fun is not None
            or isinstance(dyn_obj, gdyn.LinearDynamicsBase)
        )
        self._use_non_lin_dyn = (
            isinstance(dyn_obj, gdyn.NonlinearDynamicsBase) or ode_lst is not None
        ) and not self._use_lin_dyn

        # allow for linear or non linear dynamics by calling the appropriate parent
        if self._use_lin_dyn:
            KalmanFilter.set_state_model(
                self,
                state_mat=state_mat,
                input_mat=input_mat,
                cont_time=cont_time,
                state_mat_fun=state_mat_fun,
                input_mat_fun=input_mat_fun,
                dyn_obj=dyn_obj,
            )
        elif self._use_non_lin_dyn:
            ExtendedKalmanFilter.set_state_model(self, dyn_obj=dyn_obj, ode_lst=ode_lst)
        else:
            raise RuntimeError("Invalid state model.")

    def set_measurement_model(self, meas_mat=None, meas_fun=None):
        r"""Sets the measurement model for the filter.

        This can either set the constant measurement matrix, or a potentially
        non-linear function.

        Notes
        -----
        This assumes a measurement model of the form

        .. math::
            \tilde{y}_{k+1} = H x_{k+1}^-

        for the measurement matrix case. Or of the form

        .. math::
            \tilde{y}_{k+1} = h(t, x_{k+1}^-)

        for the potentially non-linear case.

        Parameters
        ----------
        meas_mat : Nm x N numpy array, optional
            Measurement matrix that transforms the state to estimated
            measurements. The default is None.
        meas_fun : callable, optional
            Function that transforms the state to estimated measurements. Must
            have the signature :code:`h(t, x, *args)` where `t` is the timestep,
            `x` is an N x 1 numpy array of the current state, and return an
            Nm x 1 numpy array of the estimated measurement. The default is None.

        Raises
        ------
        RuntimeError
            Rasied if no arguments are specified.
        """
        super().set_measurement_model(meas_mat=meas_mat, meas_fun_lst=meas_fun)

    def _factorize_cov(self, val=None):
        if val is None:
            val = self.cov
        # numpy linalg is lower triangular
        self._sqrt_cov = la.cholesky(val)

    def _pred_update_cov(self):
        self.cov = self.proc_noise + self.quadPoints.cov

    def _predict_next_state(
        self, timestep, cur_state, cur_input, state_mat_args, input_mat_args, dyn_fun_params
    ):
        if self._use_lin_dyn:
            return KalmanFilter._predict_next_state(
                        self,
                        timestep,
                        cur_state.reshape((-1, 1)),
                        cur_input,
                        state_mat_args,
                        input_mat_args,
                    )[0]
        elif self._use_non_lin_dyn:
            return ExtendedKalmanFilter._predict_next_state(
                        self, timestep, cur_state.reshape((-1, 1)), dyn_fun_params
                    )[0]
        else:
            raise RuntimeError("State model not specified")

    def predict(
        self, timestep, cur_state, cur_input=None, state_mat_args=None, input_mat_args=None, dyn_fun_params=None,
    ):
        """Prediction step of the filter.

        Parameters
        ----------
        timestep : float
            Current timestep.
        cur_state : N x 1 numpy array
            Current state.
        cur_input : N x Nu numpy array, optional
            Current input. The default is None.
        state_mat_args : tuple, optional
            Additional arguments for the get state matrix function if one has
            been specified, the propagate state function if using a dynamic
            object, or the dynamic function is a non-linear model is used.
            The default is ().
        input_mat_args : tuple, optional
            Additional arguments for the get input matrix function if one has
            been specified or the propagate state function if using a dynamic
            object. The default is ().
        dyn_fun_params : tuple, optional
            Additional arguments to pass to the dynamics function if using non-linear
            dynamics.

        Raises
        ------
        RuntimeError
            If the state model has not been set

        Returns
        -------
        N x 1 numpy array
            The predicted state.
        """
        if state_mat_args is None:
            state_mat_args = ()
        if input_mat_args is None:
            input_mat_args = ()
        if dyn_fun_params is None:
            dyn_fun_params = ()

        # factorize covariance as P = sqrt(P) * sqrt(P)^T
        self._factorize_cov()

        # generate quadrature points as X_i = sqrt(P) * xi_i + x_hat for m points
        self.quadPoints.update_points(cur_state, self._sqrt_cov, have_sqrt=True)

        # predict each point using the dynamics
        for ii, (point, _) in enumerate(self.quadPoints):
            pred_point = self._predict_next_state(
                timestep, point, cur_input, state_mat_args, input_mat_args, dyn_fun_params
            )
            self.quadPoints.points[ii, :] = pred_point.ravel()
        # update covariance as Q - m * x * x^T + sum(w_i * X_i * X_i^T)
        self._pred_update_cov()

        return self.quadPoints.mean

    def _corr_update_cov(self, gain, inov_cov):
        self.cov = self.cov - gain @ inov_cov @ gain.T
        self.cov = 0.5 * (self.cov + self.cov.T)

    def _est_meas(self, timestep, cur_state, n_meas, meas_fun_args):
        if self._meas_fnc is not None:
            return self._meas_fnc(timestep, cur_state, *meas_fun_args).ravel()
        else:
            return (
                super()._est_meas(timestep, cur_state, n_meas, meas_fun_args)[0].ravel()
            )

    def _corr_core(self, timestep, cur_state, meas, meas_fun_args):
        # factorize covariance as P = sqrt(P) * sqrt(P)^T
        self._factorize_cov()

        # generate quadrature points as X_i = sqrt(P) * xi_i + x_hat for m points
        self.quadPoints.update_points(cur_state, self._sqrt_cov, have_sqrt=True)

        # Estimate a measurement for each quad point, Z_i
        measQuads = gdistrib.QuadraturePoints(num_axes=meas.size)
        measQuads.points = np.nan * np.ones(
            (self.quadPoints.points.shape[0], meas.size)
        )
        measQuads.weights = self.quadPoints.weights
        for ii, (point, _) in enumerate(self.quadPoints):
            measQuads.points[ii, :] = self._est_meas(
                timestep, point, meas.size, meas_fun_args
            )
        # estimate predicted measurement as sum of est measurement quad points
        est_meas = measQuads.mean

        return measQuads, est_meas

    def correct(self, timestep, meas, cur_state, meas_fun_args=()):
        """Implements the correction step of the filter.

        Parameters
        ----------
        timestep : float
            Current timestep.
        meas : Nm x 1 numpy array
            Current measurement.
        cur_state : N x 1 numpy array
            Current state.
        meas_fun_args : tuple, optional
            Arguments for the measurement matrix function if one has
            been specified. The default is ().

        Raises
        ------
        :class:`.errors.ExtremeMeasurementNoiseError`
            If estimating the measurement noise and the measurement fit calculation fails.
        LinAlgError
            Numpy exception raised if not estimating noise and measurement fit fails.

        Returns
        -------
        next_state : N x 1 numpy array
            The corrected state.
        meas_fit_prob : float
            Goodness of fit of the measurement based on the state and
            covariance assuming Gaussian noise.

        """
        measQuads, est_meas = self._corr_core(timestep, cur_state, meas, meas_fun_args)

        # estimate the measurement noise online if applicable
        if self._est_meas_noise_fnc is not None:
            self.meas_noise = self._est_meas_noise_fnc(est_meas, measQuads.cov)
        # estimate innovation cov as P_zz = R - m * z_hat * z_hat^T + sum(w_i * Z_i * Z_i^T)
        inov_cov = self.meas_noise + measQuads.cov

        if self.use_cholesky_inverse:
            sqrt_inv_inov_cov = la.inv(la.cholesky(inov_cov))
            inv_inov_cov = sqrt_inv_inov_cov.T @ sqrt_inv_inov_cov
        else:
            inv_inov_cov = la.inv(inov_cov)
        # estimate cross cov as P_xz = sum(w_i * X_i * Z_i^T) - m * x * z_hat^T
        cov_lst = [None] * self.quadPoints.num_points
        for ii, (qp, mp) in enumerate(zip(self.quadPoints, measQuads)):
            cov_lst[ii] = (qp[0] - cur_state) @ (mp[0] - est_meas).T
        cross_cov = gmath.weighted_sum_mat(self.quadPoints.weights, cov_lst)

        # calc Kalman gain as K = P_xz * P_zz^-1
        gain = cross_cov @ inv_inov_cov

        # state is x_hat + K *(z - z_hat)
        innov = meas - est_meas
        cor_state = cur_state + gain @ innov

        # update covariance as P = P_k - K * P_zz * K^T
        self._corr_update_cov(gain, inov_cov)

        meas_fit_prob = self._calc_meas_fit(meas, est_meas, inov_cov)

        return (cor_state, meas_fit_prob)

    def plot_quadrature(self, inds, **kwargs):
        """Wrapper function for :meth:`gncpy.distributions.QuadraturePoints.plot_points`."""
        return self.quadPoints.plot_points(inds, **kwargs)
