import numpy as np
import numpy.linalg as la
import scipy.linalg as sla


from gncpy.filters.quadrature_kalman_filter import QuadratureKalmanFilter


class SquareRootQKF(QuadratureKalmanFilter):
    """Implementation of a Square root Quadrature Kalman Filter (SQKF).

    Notes
    -----
    This is based on :cite:`Arasaratnam2008_SquareRootQuadratureKalmanFiltering`.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self._meas_noise = np.array([[]])
        self._sqrt_p_noise = np.array([[]])
        self._sqrt_m_noise = np.array([[]])

    def save_filter_state(self):
        """Saves filter variables so they can be restored later."""
        filt_state = super().save_filter_state()

        filt_state["_meas_noise"] = self._meas_noise
        filt_state["_sqrt_p_noise"] = self._sqrt_p_noise
        filt_state["_sqrt_m_noise"] = self._sqrt_m_noise

        return filt_state

    def load_filter_state(self, filt_state):
        """Initializes filter using saved filter state.

        Attributes
        ----------
        filt_state : dict
            Dictionary generated by :meth:`save_filter_state`.
        """
        super().load_filter_state(filt_state)

        self._meas_noise = filt_state["_meas_noise"]
        self._sqrt_p_noise = filt_state["_sqrt_p_noise"]
        self._sqrt_m_noise = filt_state["_sqrt_m_noise"]

    def set_measurement_noise_estimator(self, function):
        """Sets the model used for estimating the measurement noise parameters.

        This is an optional step and the filter will work properly if this is
        not called. If it is called, the measurement noise will be estimated
        during the filter's correction step and the measurement noise attribute
        will not be used.

        Parameters
        ----------
        function : callable
            A function that implements the prediction and correction steps for
            an appropriate filter to estimate the measurement noise covariance
            matrix. It must have the signature `f(est_meas)` where `est_meas`
            is an Nm x 1 numpy array and it must return an Nm x Nm numpy array
            representing the measurement noise covariance matrix.

        Returns
        -------
        None.
        """
        self._est_meas_noise_fnc = function

    @property
    def cov(self):
        """Covariance of the filter."""
        # sqrt cov is lower triangular
        return self._sqrt_cov @ self._sqrt_cov.T

    @cov.setter
    def cov(self, val):
        if val.size == 0:
            self._sqrt_cov = val
        else:
            super()._factorize_cov(val=val)

    @property
    def proc_noise(self):
        """Process noise of the filter."""
        return self._sqrt_p_noise @ self._sqrt_p_noise.T

    @proc_noise.setter
    def proc_noise(self, val):
        if val.size == 0 or np.all(val == 0):
            self._sqrt_p_noise = val
        else:
            self._sqrt_p_noise = la.cholesky(val)

    @property
    def meas_noise(self):
        """Measurement noise of the filter."""
        return self._sqrt_m_noise @ self._sqrt_m_noise.T

    @meas_noise.setter
    def meas_noise(self, val):
        if val.size == 0 or np.all(val == 0):
            self._sqrt_m_noise = val
        else:
            self._sqrt_m_noise = la.cholesky(val)

    def _factorize_cov(self):
        pass

    def _pred_update_cov(self):
        weight_mat = np.diag(np.sqrt(self.quadPoints.weights))
        x_hat = self.quadPoints.mean
        state_mat = np.concatenate(
            [x.reshape((x.size, 1)) - x_hat for x in self.quadPoints.points], axis=1
        )

        self._sqrt_cov = la.qr(
            np.concatenate((state_mat @ weight_mat, self._sqrt_p_noise.T), axis=1).T,
            mode="r",
        ).T

    def _corr_update_cov(self, gain, state_mat, meas_mat):
        self._sqrt_cov = la.qr(
            np.concatenate(
                (state_mat - gain @ meas_mat, gain @ self._sqrt_m_noise), axis=1
            ).T,
            mode="r",
        ).T

    def correct(self, timestep, meas, cur_state, meas_fun_args=()):
        """Implements the correction step of the filter.

        Parameters
        ----------
        timestep : float
            Current timestep.
        meas : Nm x 1 numpy array
            Current measurement.
        cur_state : N x 1 numpy array
            Current state.
        meas_fun_args : tuple, optional
            Arguments for the measurement matrix function if one has
            been specified. The default is ().

        Raises
        ------
        :class:`.errors.ExtremeMeasurementNoiseError`
            If estimating the measurement noise and the measurement fit calculation fails.
        LinAlgError
            Numpy exception raised if not estimating noise and measurement fit fails.

        Returns
        -------
        next_state : N x 1 numpy array
            The corrected state.
        meas_fit_prob : float
            Goodness of fit of the measurement based on the state and
            covariance assuming Gaussian noise.

        """
        measQuads, est_meas = self._corr_core(timestep, cur_state, meas, meas_fun_args)

        weight_mat = np.diag(np.sqrt(self.quadPoints.weights))

        # calculate sqrt of the measurement covariance
        meas_mat = (
            np.concatenate(
                [z.reshape((z.size, 1)) - est_meas for z in measQuads.points], axis=1
            )
            @ weight_mat
        )
        if self._est_meas_noise_fnc is not None:
            self.meas_noise = self._est_meas_noise_fnc(est_meas, meas_mat @ meas_mat.T)
        sqrt_inov_cov = la.qr(
            np.concatenate((meas_mat, self._sqrt_m_noise), axis=1).T, mode="r"
        ).T

        # calculate cross covariance
        x_hat = self.quadPoints.mean
        state_mat = (
            np.concatenate(
                [x.reshape((x.size, 1)) - x_hat for x in self.quadPoints.points], axis=1
            )
            @ weight_mat
        )
        cross_cov = state_mat @ meas_mat.T

        # calculate gain
        inter = sla.solve_triangular(sqrt_inov_cov.T, cross_cov.T)
        gain = sla.solve_triangular(sqrt_inov_cov, inter, lower=True).T

        # the above gain is equavalent to
        # inv_sqrt_inov_cov = la.inv(sqrt_inov_cov)
        # gain = cross_cov @ (inv_sqrt_inov_cov.T @ inv_sqrt_inov_cov)

        # state is x_hat + K *(z - z_hat)
        innov = meas - est_meas
        cor_state = cur_state + gain @ innov

        # update covariance
        inov_cov = sqrt_inov_cov @ sqrt_inov_cov.T

        self._corr_update_cov(gain, state_mat, meas_mat)

        meas_fit_prob = self._calc_meas_fit(meas, est_meas, inov_cov)

        return (cor_state, meas_fit_prob)
